package transpiler

import (
	"benlang/internal/parser"
	"fmt"
	"strings"
)

// Transpiler converts BenLang AST to JavaScript
type Transpiler struct {
	indentLevel int
}

// New creates a new Transpiler
func New() *Transpiler {
	return &Transpiler{indentLevel: 0}
}

// Transpile converts a BenLang program to JavaScript
func (t *Transpiler) Transpile(program *parser.Program) string {
	var out strings.Builder

	// Add runtime initialization
	out.WriteString("// Generated by BenLang Transpiler\n")
	out.WriteString("'use strict';\n\n")

	for _, stmt := range program.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}

	return out.String()
}

func (t *Transpiler) indent() string {
	return strings.Repeat("  ", t.indentLevel)
}

func (t *Transpiler) transpileStatement(stmt parser.Statement) string {
	switch s := stmt.(type) {
	case *parser.VariableDeclaration:
		return t.transpileVariableDeclaration(s)
	case *parser.FigurDeclaration:
		return t.transpileFigurDeclaration(s)
	case *parser.FunctionDeclaration:
		return t.transpileFunctionDeclaration(s)
	case *parser.ReturnStatement:
		return t.transpileReturnStatement(s)
	case *parser.ExpressionStatement:
		return t.indent() + t.transpileExpression(s.Expression) + ";"
	case *parser.IfStatement:
		return t.transpileIfStatement(s)
	case *parser.WhileStatement:
		return t.transpileWhileStatement(s)
	case *parser.ForStatement:
		return t.transpileForStatement(s)
	case *parser.RepeatStatement:
		return t.transpileRepeatStatement(s)
	case *parser.GameDeclaration:
		return t.transpileGameDeclaration(s)
	case *parser.EventHandler:
		return t.transpileEventHandler(s)
	default:
		return ""
	}
}

func (t *Transpiler) transpileVariableDeclaration(vd *parser.VariableDeclaration) string {
	value := t.transpileExpression(vd.Value)
	return fmt.Sprintf("%svar %s = %s;", t.indent(), vd.Name.Value, value)
}

func (t *Transpiler) transpileFigurDeclaration(fd *parser.FigurDeclaration) string {
	value := t.transpileExpression(fd.Value)
	return fmt.Sprintf("%svar %s = %s;", t.indent(), fd.Name.Value, value)
}

func (t *Transpiler) transpileFunctionDeclaration(fd *parser.FunctionDeclaration) string {
	params := make([]string, len(fd.Parameters))
	for i, p := range fd.Parameters {
		params[i] = p.Value
	}

	var out strings.Builder
	out.WriteString(fmt.Sprintf("%sasync function %s(%s) {\n",
		t.indent(), fd.Name.Value, strings.Join(params, ", ")))

	t.indentLevel++
	for _, stmt := range fd.Body.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}
	t.indentLevel--

	out.WriteString(t.indent() + "}")
	return out.String()
}

func (t *Transpiler) transpileReturnStatement(rs *parser.ReturnStatement) string {
	if rs.ReturnValue == nil {
		return t.indent() + "return;"
	}
	return fmt.Sprintf("%sreturn %s;", t.indent(), t.transpileExpression(rs.ReturnValue))
}

func (t *Transpiler) transpileIfStatement(is *parser.IfStatement) string {
	var out strings.Builder

	condition := t.transpileExpression(is.Condition)
	out.WriteString(fmt.Sprintf("%sif (%s) {\n", t.indent(), condition))

	t.indentLevel++
	for _, stmt := range is.Consequence.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}
	t.indentLevel--

	if is.Alternative != nil {
		// Check if alternative is an else-if
		if len(is.Alternative.Statements) == 1 {
			if elseIf, ok := is.Alternative.Statements[0].(*parser.IfStatement); ok {
				out.WriteString(t.indent() + "} else ")
				// Remove indent from the nested if since we're continuing on the same line
				t.indentLevel++
				nestedIf := t.transpileIfStatement(elseIf)
				t.indentLevel--
				// Remove leading indent from nested if
				nestedIf = strings.TrimPrefix(nestedIf, t.indent()+"  ")
				out.WriteString(nestedIf)
				return out.String()
			}
		}

		out.WriteString(t.indent() + "} else {\n")
		t.indentLevel++
		for _, stmt := range is.Alternative.Statements {
			out.WriteString(t.transpileStatement(stmt))
			out.WriteString("\n")
		}
		t.indentLevel--
	}

	out.WriteString(t.indent() + "}")
	return out.String()
}

func (t *Transpiler) transpileWhileStatement(ws *parser.WhileStatement) string {
	var out strings.Builder

	condition := t.transpileExpression(ws.Condition)
	out.WriteString(fmt.Sprintf("%swhile (%s) {\n", t.indent(), condition))

	t.indentLevel++
	for _, stmt := range ws.Body.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}
	t.indentLevel--

	out.WriteString(t.indent() + "}")
	return out.String()
}

func (t *Transpiler) transpileForStatement(fs *parser.ForStatement) string {
	var out strings.Builder

	varName := fs.Variable.Value
	start := t.transpileExpression(fs.Start)
	end := t.transpileExpression(fs.End)

	out.WriteString(fmt.Sprintf("%sfor (let %s = %s; %s <= %s; %s++) {\n",
		t.indent(), varName, start, varName, end, varName))

	t.indentLevel++
	for _, stmt := range fs.Body.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}
	t.indentLevel--

	out.WriteString(t.indent() + "}")
	return out.String()
}

func (t *Transpiler) transpileRepeatStatement(rs *parser.RepeatStatement) string {
	var out strings.Builder

	count := t.transpileExpression(rs.Count)
	out.WriteString(fmt.Sprintf("%sfor (let _i = 0; _i < %s; _i++) {\n", t.indent(), count))

	t.indentLevel++
	for _, stmt := range rs.Body.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}
	t.indentLevel--

	out.WriteString(t.indent() + "}")
	return out.String()
}

func (t *Transpiler) transpileGameDeclaration(gd *parser.GameDeclaration) string {
	return fmt.Sprintf("%s_benlang.spielName = %q;", t.indent(), gd.Name)
}

func (t *Transpiler) transpileEventHandler(eh *parser.EventHandler) string {
	var out strings.Builder

	switch eh.EventType {
	case "start":
		out.WriteString(fmt.Sprintf("%s_benlang.wennStart(async function() {\n", t.indent()))
	case "immer":
		out.WriteString(fmt.Sprintf("%s_benlang.wennImmer(async function() {\n", t.indent()))
	case "taste":
		if len(eh.Parameters) > 0 {
			taste := t.transpileExpression(eh.Parameters[0])
			out.WriteString(fmt.Sprintf("%s_benlang.wennTaste(%s, async function() {\n", t.indent(), taste))
		}
	case "kollision":
		if len(eh.Parameters) >= 2 {
			a := t.transpileExpression(eh.Parameters[0])
			b := t.transpileExpression(eh.Parameters[1])
			out.WriteString(fmt.Sprintf("%s_benlang.wennKollision(%s, %s, async function() {\n", t.indent(), a, b))
		}
	}

	t.indentLevel++
	for _, stmt := range eh.Body.Statements {
		out.WriteString(t.transpileStatement(stmt))
		out.WriteString("\n")
	}
	t.indentLevel--

	out.WriteString(t.indent() + "});")
	return out.String()
}

func (t *Transpiler) transpileExpression(expr parser.Expression) string {
	if expr == nil {
		return ""
	}

	switch e := expr.(type) {
	case *parser.Identifier:
		return e.Value
	case *parser.NumberLiteral:
		return e.Token.Literal
	case *parser.StringLiteral:
		return fmt.Sprintf("%q", e.Value)
	case *parser.BooleanLiteral:
		if e.Value {
			return "true"
		}
		return "false"
	case *parser.ArrayLiteral:
		return t.transpileArrayLiteral(e)
	case *parser.IndexExpression:
		return t.transpileIndexExpression(e)
	case *parser.PrefixExpression:
		return t.transpilePrefixExpression(e)
	case *parser.InfixExpression:
		return t.transpileInfixExpression(e)
	case *parser.CallExpression:
		return t.transpileCallExpression(e)
	case *parser.MemberExpression:
		return t.transpileMemberExpression(e)
	case *parser.AssignmentExpression:
		return t.transpileAssignmentExpression(e)
	default:
		return ""
	}
}

func (t *Transpiler) transpileArrayLiteral(al *parser.ArrayLiteral) string {
	elements := make([]string, len(al.Elements))
	for i, el := range al.Elements {
		elements[i] = t.transpileExpression(el)
	}
	return "[" + strings.Join(elements, ", ") + "]"
}

func (t *Transpiler) transpileIndexExpression(ie *parser.IndexExpression) string {
	return fmt.Sprintf("%s[%s]",
		t.transpileExpression(ie.Left),
		t.transpileExpression(ie.Index))
}

func (t *Transpiler) transpilePrefixExpression(pe *parser.PrefixExpression) string {
	operator := pe.Operator
	// Convert German operator NICHT to JavaScript !
	if strings.ToLower(operator) == "nicht" {
		operator = "!"
	}
	return fmt.Sprintf("(%s%s)", operator, t.transpileExpression(pe.Right))
}

func (t *Transpiler) transpileInfixExpression(ie *parser.InfixExpression) string {
	left := t.transpileExpression(ie.Left)
	right := t.transpileExpression(ie.Right)
	operator := ie.Operator

	// Convert German operators to JavaScript
	switch strings.ToLower(operator) {
	case "und":
		operator = "&&"
	case "oder":
		operator = "||"
	}

	return fmt.Sprintf("(%s %s %s)", left, operator, right)
}

func (t *Transpiler) transpileCallExpression(ce *parser.CallExpression) string {
	funcName := t.transpileExpression(ce.Function)

	// Map German built-in functions to runtime functions
	funcMapping := map[string]string{
		"LADE_BILD":        "_benlang.ladeBild",
		"BILD_WECHSELN":    "await _benlang.bildWechseln",
		"SPIELE_TON":       "_benlang.spieleTon",
		"ZEIGE_TEXT":       "_benlang.zeigeText",
		"ZEICHNE_RECHTECK": "_benlang.zeichneRechteck",
		"ZEICHNE_KREIS":    "_benlang.zeichneKreis",
		"ZEICHNE_LINIE":    "_benlang.zeichneLinie",
		"TASTE_GEDRUECKT":  "_benlang.tasteGedrueckt",
		"TASTE_GEDRÜCKT":   "_benlang.tasteGedrueckt",
		"TASTE_GETIPPT":    "_benlang.tasteGetippt",
		"GEDRUECKTE_TASTE": "_benlang.gedrueckteTaste",
		"GEDRÜCKTE_TASTE":  "_benlang.gedrueckteTaste",
		"MAUS_X":           "_benlang.mausX",
		"MAUS_Y":           "_benlang.mausY",
		"MAUS_GEDRUECKT":   "_benlang.mausGedrueckt",
		"MAUS_GEDRÜCKT":    "_benlang.mausGedrueckt",
		"ZUFALL":           "_benlang.zufall",
		"WARTE":            "await _benlang.warte",
		"RUNDEN":           "Math.round",
		"ABSOLUT":          "Math.abs",
		"WURZEL":           "Math.sqrt",
		"SINUS":            "Math.sin",
		"KOSINUS":          "Math.cos",
		"SCHREIBE":         "console.log",
		"FRAGE":            "await _benlang.frage",
		"LOESCHEN":         "_benlang.loescheFigur",
		"LÖSCHEN":          "_benlang.loescheFigur",
		"LAENGE":           "_benlang.laenge",
		"ZEICHEN":          "_benlang.zeichen",
		"GROSSBUCHSTABEN":  "_benlang.grossbuchstaben",
		"GEHE_ZU":          "_benlang.geheZu",
		"DREHE":            "_benlang.drehe",
		"SKALIERE":         "_benlang.skaliere",
	}

	args := make([]string, len(ce.Arguments))
	for i, arg := range ce.Arguments {
		args[i] = t.transpileExpression(arg)
	}

	if mapped, ok := funcMapping[funcName]; ok {
		return fmt.Sprintf("%s(%s)", mapped, strings.Join(args, ", "))
	}

	// User-defined functions are async, so we need to await them
	// Check if it's a simple identifier (user function) vs member expression
	if _, ok := ce.Function.(*parser.Identifier); ok {
		return fmt.Sprintf("await %s(%s)", funcName, strings.Join(args, ", "))
	}

	return fmt.Sprintf("%s(%s)", funcName, strings.Join(args, ", "))
}

func (t *Transpiler) transpileMemberExpression(me *parser.MemberExpression) string {
	return fmt.Sprintf("%s.%s",
		t.transpileExpression(me.Object),
		strings.ToLower(me.Property.Value))
}

func (t *Transpiler) transpileAssignmentExpression(ae *parser.AssignmentExpression) string {
	return fmt.Sprintf("%s = %s",
		t.transpileExpression(ae.Left),
		t.transpileExpression(ae.Value))
}
